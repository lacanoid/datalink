#!/usr/bin/perl

use strict;
use DBI;
use JSON;
use IPC::Run 'run';
use Getopt::Std;
use Time::HiRes qw{usleep};

BEGIN { $ENV{LC_ALL} = "C"; }

our $opt_v = 0;  # verbosity
our $opt_n = 10; # number of iterations in fast inner loop
our $opt_D = 0;  # really delete linked files with ON UNLINK DELETE

getopt('');

our @wget = qw{wget --verbose --adjust-extension --span-hosts --convert-links --backup-converted --page-requisites};

our %config = (
    appname => 'SQL/MED like datalinker',
    dsn => 'dbi:Pg:service=datalinker',
    db_owner => 'postgres.postgres',
    db_mode => '0440',
    url_archive => "/var/www/datalink_url",
    prefix => [
	"/var/www/datalink_fs/",
	"/tmp/"
    ]
);

our $dbh = DBI->connect($config{dsn});
if(!$dbh) { log_fatal("Database not available"); }

our $json = JSON->new->allow_nonref;

$dbh->do("set application_name='".$config{appname}."'");
$dbh->do("set search_path=datalink");
$dbh->do('listen "datalink.linker_jobs"');

my %q = (
    'get_jobs'=>$dbh->prepare(q{
       select * 
         from dl_linked_files 
         join dl_link_control_options lco using (lco)
        where state in ('LINK','UNLINK')
    }),
    'set_linked'=>$dbh->prepare(q{
       update dl_linked_files 
          set state = 'LINKED',
              info = $2
        where path = $1
    }),
    'delete'=>$dbh->prepare(q{
       delete from dl_linked_files
        where path = $1
    })
);

our $dbmeta = $dbh->selectrow_hashref(qq{
  select current_database(), current_timestamp,
         (select count(*) from pg_stat_activity
           where application_name='}.$config{appname}.q{')
         as nl
});
    
log_msg("START",$dbmeta);

if($dbmeta->{nl}>1) {
    log_err("DUPE","There seems to be a dataliker already running!");
}

while(1) {
    log_debug('READY');
    my $sleepy = 0;
    while(!$sleepy) {
	my $rv = $q{get_jobs}->execute;
	if(!defined($rv)) { log_fatal("Can't execute main query. Bugs?"); }
	$sleepy = $rv<=0;
	if(!$sleepy) {
	    while(my $data = $q{get_jobs}->fetchrow_hashref) {
		if(!$data->{token}) {
		    log_err("No token in ",$data);
		    next;
		}
		if($data->{info}) { $data->{info}=$json->decode($data->{info}); }
		log_debug("DATA",$data);
		if($data->{state} eq 'LINK') {
		    log_msg('LINK:'.$data->{lco},$data->{path});
		    my $r=file_link($data->{path},$data);
		    $q{set_linked}->execute($data->{path},$json->encode($r));
		}
		elsif($data->{state} eq 'UNLINK') {
		    log_msg('UNLINK:'.$data->{lco},$data->{path});
		    file_unlink($data->{path},$data);
		    $q{delete}->execute($data->{path});
		}
		else {
		    log_err("Unknown state in ",$data);
		    next;
		}
	    }
	}
    }
    for(my $i=0;$i<$opt_n;$i++) {
	while(my $not = $dbh->pg_notifies) {
	    log_debug('NOTIFY',$not);
	    $sleepy = 0;
	}
	if($sleepy) {
	    usleep(1000000 * 5.0/$opt_n);
	}
    }
} # forever loop

log_msg('END');
exit;

########################################
# path management

sub path_backup {
    my ($path,$token)=@_;
    if($token) { return $path.'#'.$token; }
    else { return $path; }
}

sub path_valid {
    
}

########################################
# file management

sub file_stat {
    my ($path,$opt)=@_;
    my (@s) = stat($path);

    return {
	'dev'=>$s[0],'inode'=>$s[1],'mode'=>$s[2],'nlink'=>$s[3],
	'uid'=>$s[4],'gid'=>$s[5], 'rdev'=>$s[6],'size'=>$s[7],
#	'atime'=>time2str("%C",$s[8]),'mtime'=>time2str("%C",$s[9]),'ctime'=>time2str("%C",$s[10]),
	'blksize'=>$s[11],'blocks'=>$s[12]
    };
}

sub file_link {
    my ($path,$opt)=@_;
    my $s = file_stat($path);
    my $r = { own => $s->{uid}.":".$s->{gid}, 
	      mod => sprintf("%#o",$s->{mode} & 0777),
	      lco => $opt->{lco},
              token => $opt->{token},
              addr => '{'.$s->{dev}.','.$s->{inode}.'}'
    };

    if($opt->{recovery} eq 'YES') {
	file_backup($path,$opt);
    }
    if($opt->{read_access} eq 'DB') {
	file_read_permission_db($path,$opt);
    }

    file_block($path);
    return $r;
}

sub file_unlink {
    my ($path,$opt)=@_;
    file_unblock($path,$opt);
    file_restore($path,$opt);
}

sub file_read_permission_db {
    my ($path,$opt)=@_;
    log_debug('CHOWNMOD',$opt);
    if(defined($config{db_owner})) {
	sys("chown",$config{db_owner},$path);
    }
    if(defined($config{db_mode})) {
	sys("chmod",$config{db_mode},$path);
    }
}

sub file_restore {
    my ($path,$opt)=@_;
    my $info = $opt->{info};
    log_debug('RESTORE',$info);
    if(defined($info->{own})) {
	sys("chown",$info->{own},$path);
    }
    if(defined($info->{mod})) {
	sys("chmod",$info->{mod},$path);
    }
}

sub file_backup {
    my ($path,$opt)=@_;
    if($opt->{token}) {
	my $path_backup = path_backup($path,$opt->{token});
	sys("cp","-a",$path,$path_backup);
    }
}

sub file_block {
    my ($path,$opt)=@_;
    sys("chattr","+i",$path);
}

sub file_unblock {
    my ($path,$opt)=@_;
    sys("chattr","-i",$path);
}

########################################
# run sys commands

sub sys {
    my @args = @_;
    my $err;
    log_msg("SYS",[@args]);
    system(@args) == 0
	or log_err('SYSFAIL',"system @args failed: $?");

    if ($? == -1) {
	$err = "failed to execute: $!";
    }
    elsif ($? & 127) {
	$err = sprintf "child died with signal %d, %s coredump",
	($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
	my $ex = $? >> 8;
	if($ex > 0) {
	    $err = sprintf "child exited with value %d", $ex;
	}
    }
    if($err) { log_err('SYSERR',$err); }
}

########################################
# run wget to arhive webpages (not used yet)

sub wget {
    my ($u)=@_;
    my @c = @wget;
    push @c,$u;

    my $start_time = [Time::HiRes::gettimeofday()];

    chdir($config{url_archive});
    run [ @c ], '2>', \my $res;

    my %rc;
    while($res=~s/response\.\.\.\s*(\d+)//) {
	$rc{$1}++;
    }

    my $diff = Time::HiRes::tv_interval($start_time);

    return {'t'=>$diff, 'rc'=>\%rc };
}

########################################
# logging

sub log_debug {
    my ($txt,$data)=@_;
    if($opt_v) {
	print "$txt:".(ref($data)?$json->pretty->encode($data):$data)."\n";
    }
}

sub log_msg {
    my ($txt,$data)=@_;
    print "$txt:".(ref($data)?$json->encode($data):$data)."\n";
}

sub log_err {
    my ($txt,$data)=@_;
    print STDERR "$txt:".(ref($data)?$json->pretty->encode($data):$data)."\n";
}

sub log_fatal {
    my ($txt)=@_;
    die $txt;
}
